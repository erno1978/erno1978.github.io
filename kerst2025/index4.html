<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactieve Schuifpuzzel - Fijne Feestdagen</title>
    <style>
        /* Consistent, kort en krachtig CSS */
        /* PUNT 1: Kerstachtige verloop achtergrond */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            /* Groen/rood verloop */
            background: linear-gradient(135deg, #1e5e2e 0%, #a71d31 100%); 
            color: #fff; /* Witte tekst voor contrast */
        }

        h1 {
            color: #ffe0b2; /* Lichte kleur voor de titel */
            margin-bottom: 20px;
        }

        /* De container is vast 800x800 */
        #puzzle-container {
            width: 800px; 
            height: 800px;
            display: grid;
            border: 5px solid #ffe0b2; /* Lichte rand */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        /* Stijl voor elk tegelvakje */
        .tile {
            background-size: 800px 800px; 
            cursor: pointer;
            transition: transform 0.3s, opacity 0.3s; 
            border: 1px solid #ffe0b2; 
            box-sizing: border-box; 
        }

        /* De lege tegel */
        .empty {
            background-image: none !important;
            background-color: #555; /* Donkergrijs/zwart voor contrast met kerstkleuren */
            cursor: default;
        }

        #message {
            margin-top: 30px;
            font-size: 2em;
            color: #ffeb3b; /* Geel/Goud kleur */
            font-weight: bold;
            display: none;
        }

        /* Flexibele container voor de knoppen en dropdown */
        #controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap; 
            justify-content: center;
            gap: 10px;
        }
        
        #controls button, #controls select {
            padding: 10px 15px;
            font-size: 1em;
            cursor: pointer;
            background-color: #ffe0b2; /* Lichte knopkleur */
            color: #1e5e2e; /* Donkergroene tekst */
            border: none;
            border-radius: 5px;
            white-space: nowrap;
        }

        /* Specifieke stijl voor de 'Oplossing'-knop (rood) */
        #solve-button {
            background-color: #a71d31; /* Rood */
            color: #ffe0b2; /* Lichte tekst */
        }
    </style>
</head>
<body>

    <h1>We wensen jullie fijne feestdagen...</h1>

    <div id="puzzle-container">
    </div>

    <div id="controls">
        <button id="shuffle-button">Opnieuw Schudden</button>
        
        <select id="difficulty-select">
            <option value="4">Standaard (4x4)</option>
            <option value="3">Iets makkelijker (3x3)</option>
            <option value="5">Uitdaging (5x5)</option>
        </select>
        
        <button id="solve-button">Help, ik kom er echt niet uit!</button>
    </div>

    <div id="message">... en een jaar waarin alle stukjes op hun plek vallen!</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.getElementById('puzzle-container');
            const message = document.getElementById('message');
            const shuffleButton = document.getElementById('shuffle-button');
            const solveButton = document.getElementById('solve-button');
            const difficultySelect = document.getElementById('difficulty-select'); // Nieuwe dropdown
            
            // Globale variabele voor de rastergrootte (standaard 4x4)
            let size = 4; 
            let tiles = []; 
            let currentBoard = []; 

            /**
             * Genereert de puzzeltegels en reset de container.
             */
            function createTiles() {
                container.innerHTML = '';
                message.style.display = 'none';
                container.style.border = '5px solid #ffe0b2';
                const totalTiles = size * size;
                const tileSize = 800 / size; 
                
                // Pas de CSS Grid aan op basis van de grootte
                container.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
                container.style.gridTemplateRows = `repeat(${size}, 1fr)`;

                tiles = [];
                for (let i = 0; i < totalTiles; i++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.dataset.index = i; 
                    
                    if (i < totalTiles - 1) { 
                        const row = Math.floor(i / size);
                        const col = i % size;
                        
                        const backgroundX = -col * tileSize;
                        const backgroundY = -row * tileSize;

                        tile.style.backgroundImage = `url('kerst.jpg')`;
                        tile.style.backgroundPosition = `${backgroundX}px ${backgroundY}px`;
                        tile.addEventListener('click', handleTileClick);
                    } else {
                        tile.classList.add('empty');
                    }
                    tiles.push(tile);
                }
                currentBoard = Array.from(tiles);
            }

            /**
             * Render de huidige tegels op het bord.
             */
            function renderTiles(array) {
                container.innerHTML = '';
                array.forEach(tile => container.appendChild(tile));
                currentBoard = Array.from(array);
            }
            
            /**
             * Controleert op oplosbaarheid.
             */
            function isSolvable(array) {
                 if (size % 2 === 0) {
                    // Voor 4x4: We schudden gewoon en nemen het risico, tenzij we meer complexe logica willen.
                    return true; 
                 }
                // Oplosbaarheidscheck voor oneven rasters (3x3, 5x5)
                let inversions = 0;
                const tileIndices = array
                    .filter(tile => !tile.classList.contains('empty'))
                    .map(tile => parseInt(tile.dataset.index));

                for (let i = 0; i < tileIndices.length; i++) {
                    for (let j = i + 1; j < tileIndices.length; j++) {
                        if (tileIndices[i] > tileIndices[j]) {
                            inversions++;
                        }
                    }
                }
                return inversions % 2 === 0;
            }

            /**
             * Schuift de tegels.
             */
            function shuffle() {
                let shuffledTiles;
                const totalTiles = size * size;

                do {
                    shuffledTiles = tiles.slice(0, totalTiles - 1)
                        .sort(() => Math.random() - 0.5);
                    
                    const emptyTile = tiles[totalTiles - 1];
                    shuffledTiles.push(emptyTile);
                } while (!isSolvable(shuffledTiles)); 

                renderTiles(shuffledTiles); 
            }
            
            /**
             * Verandert de grootte en start de puzzel opnieuw (via dropdown).
             */
            function setSizeAndRestart(newSize) {
                if (size !== newSize) {
                    size = newSize;
                    // Reset de puzzel
                    createTiles();
                    shuffle();
                }
            }

            // ... (canMove, swapTiles, handleTileClick, isSolved, handleSolved functies blijven hetzelfde) ...
            
            function solvePuzzle() {
                renderTiles(tiles); 
                handleSolved();
            }

            function canMove(tileIndex, emptyIndex) {
                const tileRow = Math.floor(tileIndex / size);
                const tileCol = tileIndex % size;
                const emptyRow = Math.floor(emptyIndex / size);
                const emptyCol = emptyIndex % size;

                const sameRow = tileRow === emptyRow && Math.abs(tileCol - emptyCol) === 1;
                const sameCol = tileCol === emptyCol && Math.abs(tileRow - emptyRow) === 1;

                return sameRow || sameCol;
            }

            function swapTiles(index1, index2) {
                [currentBoard[index1], currentBoard[index2]] = [currentBoard[index2], currentBoard[index1]];
                renderTiles(currentBoard);
            }

            function handleTileClick(event) {
                const clickedTile = event.currentTarget;
                const tileIndex = currentBoard.indexOf(clickedTile);
                const emptyIndex = currentBoard.findIndex(tile => tile.classList.contains('empty'));

                if (canMove(tileIndex, emptyIndex)) {
                    swapTiles(tileIndex, emptyIndex);

                    if (isSolved()) {
                        handleSolved();
                    }
                }
            }

            function isSolved() {
                const totalTiles = size * size;
                return currentBoard.every((tile, index) => {
                    if (tile.classList.contains('empty')) {
                        return index === totalTiles - 1;
                    }
                    return parseInt(tile.dataset.index) === index;
                });
            }

            function handleSolved() {
                message.style.display = 'block';
                container.style.border = '5px solid #ffeb3b'; /* Goudkleurige rand */
            }


            // --- Initialisatie & Knoppen ---
            createTiles(); 
            shuffle(); 

            shuffleButton.addEventListener('click', shuffle);
            solveButton.addEventListener('click', solvePuzzle); 
            
            // Event listener voor de dropdown
            difficultySelect.addEventListener('change', (event) => {
                const newSize = parseInt(event.target.value);
                setSizeAndRestart(newSize);
            });
        });
    </script>
</body>
</html>